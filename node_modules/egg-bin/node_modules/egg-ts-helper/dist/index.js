"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const debug_1 = tslib_1.__importDefault(require("debug"));
const assert_1 = tslib_1.__importDefault(require("assert"));
const events_1 = require("events");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const config_1 = require("./config");
const watcher_1 = tslib_1.__importDefault(require("./watcher"));
const utils = tslib_1.__importStar(require("./utils"));
const globby_1 = tslib_1.__importDefault(require("globby"));
const debug = debug_1.default('egg-ts-helper#index');
exports.defaultConfig = {
    cwd: utils.convertString(process.env.ETS_CWD, process.cwd()),
    framework: utils.convertString(process.env.ETS_FRAMEWORK, 'egg'),
    typings: utils.convertString(process.env.ETS_TYPINGS, './typings'),
    caseStyle: utils.convertString(process.env.ETS_CASE_STYLE, 'lower'),
    autoRemoveJs: utils.convertString(process.env.ETS_AUTO_REMOVE_JS, true),
    throttle: utils.convertString(process.env.ETS_THROTTLE, 500),
    watch: utils.convertString(process.env.ETS_WATCH, false),
    watchOptions: undefined,
    execAtInit: utils.convertString(process.env.ETS_EXEC_AT_INIT, false),
    silent: utils.convertString(process.env.ETS_SILENT, process.env.NODE_ENV === 'test'),
    watchDirs: {},
    configFile: utils.convertString(process.env.ETS_CONFIG_FILE, './tshelper'),
};
// default watch dir
function getDefaultWatchDirs(opt = {}) {
    const baseConfig = {};
    // extend
    baseConfig.extend = {
        directory: 'app/extend',
        generator: 'extend',
    };
    // controller
    baseConfig.controller = {
        directory: 'app/controller',
        interface: config_1.declMapping.controller,
        generator: 'class',
    };
    // middleware
    baseConfig.middleware = {
        directory: 'app/middleware',
        interface: config_1.declMapping.middleware,
        generator: 'object',
    };
    // proxy
    baseConfig.proxy = {
        directory: 'app/proxy',
        interface: 'IProxy',
        generator: 'class',
        enabled: false,
    };
    // model
    const eggInfo = (opt && opt.cwd) ? utils.getEggInfo(opt.cwd) : undefined;
    const hasModelInCustomLoader = !!utils.deepGet(eggInfo, 'config.customLoader.model');
    const sequelizeInfo = utils.deepGet(eggInfo, 'plugins.sequelize') || {};
    const isUsingSequelize = sequelizeInfo.package === 'egg-sequelize' && sequelizeInfo.enable;
    baseConfig.model = Object.assign({ directory: 'app/model', generator: 'function', interface: 'IModel', caseStyle: 'upper', enabled: !hasModelInCustomLoader }, (isUsingSequelize ? {
        interface: 'Sequelize',
        framework: 'sequelize',
    } : {}));
    // config
    baseConfig.config = {
        directory: 'config',
        generator: 'config',
        trigger: ['add', 'unlink', 'change'],
    };
    // plugin
    baseConfig.plugin = {
        directory: 'config',
        generator: 'plugin',
        trigger: ['add', 'unlink', 'change'],
    };
    // service
    baseConfig.service = {
        directory: 'app/service',
        interface: config_1.declMapping.service,
        generator: 'class',
    };
    // egg
    baseConfig.egg = {
        directory: 'app',
        generator: 'egg',
        watch: false,
    };
    // custom loader
    baseConfig.customLoader = {
        generator: 'custom',
        trigger: ['add', 'unlink', 'change'],
    };
    return baseConfig;
}
exports.getDefaultWatchDirs = getDefaultWatchDirs;
class TsHelper extends events_1.EventEmitter {
    constructor(options) {
        super();
        this.watcherList = new Map();
        this.cacheDist = {};
        this.dtsFileList = [];
        // utils
        this.utils = utils;
        // configure ets
        this.configure(options);
        // clean files
        this.cleanFiles();
        // init watcher
        this.initWatcher();
    }
    // build all watcher
    build() {
        this.watcherList.forEach(watcher => watcher.execute());
        return this;
    }
    // destroy
    destroy() {
        this.removeAllListeners();
        this.watcherList.forEach(item => item.destroy());
        this.watcherList.clear();
    }
    // log
    log(info) {
        if (this.config.silent) {
            return;
        }
        utils.log(info);
    }
    // create oneForAll file
    createOneForAll(dist) {
        const config = this.config;
        const oneForAllDist = (typeof dist === 'string') ? dist : path_1.default.join(config.typings, './ets.d.ts');
        const oneForAllDistDir = path_1.default.dirname(oneForAllDist);
        // create d.ts includes all types.
        const distContent = config_1.dtsComment + this.dtsFileList
            .map(file => {
            const importUrl = path_1.default
                .relative(oneForAllDistDir, file.replace(/\.d\.ts$/, ''))
                .replace(/\/|\\/g, '/');
            return `import '${importUrl.startsWith('.') ? importUrl : `./${importUrl}`}';`;
        })
            .join('\n');
        this.emit('update', oneForAllDist);
        utils.writeFileSync(oneForAllDist, distContent);
    }
    // init watcher
    initWatcher() {
        Object.keys(this.config.watchDirs).forEach(key => {
            this.registerWatcher(key, this.config.watchDirs[key]);
        });
    }
    // destroy watcher
    destroyWatcher(name) {
        if (this.watcherList.has(name)) {
            this.watcherList.get(name).destroy();
            this.watcherList.delete(name);
        }
    }
    // clean old files in startup
    cleanFiles() {
        const cwd = this.config.typings;
        globby_1.default.sync(['**/*.d.ts', '!**/node_modules'], { cwd })
            .forEach(file => {
            const fileUrl = path_1.default.resolve(cwd, file);
            const content = fs_1.default.readFileSync(fileUrl, { encoding: 'utf-8' });
            const isGeneratedByEts = content.match(config_1.dtsCommentRE);
            if (isGeneratedByEts)
                fs_1.default.unlinkSync(fileUrl);
        });
    }
    // register watcher
    registerWatcher(name, watchConfig) {
        this.destroyWatcher(name);
        if (watchConfig.hasOwnProperty('enabled') && !watchConfig.enabled) {
            return;
        }
        const options = Object.assign({ name, execAtInit: this.config.execAtInit }, watchConfig);
        if (!this.config.watch) {
            options.watch = false;
        }
        const watcher = new watcher_1.default(this);
        watcher.on('update', this.generateTs.bind(this));
        watcher.init(options);
        this.watcherList.set(name, watcher);
        return watcher;
    }
    // configure
    // options > configFile > package.json
    configure(options) {
        if (options.cwd) {
            options.cwd = utils.getAbsoluteUrlByCwd(options.cwd, exports.defaultConfig.cwd);
        }
        // base config
        const config = Object.assign({}, exports.defaultConfig);
        const configFile = options.configFile || config.configFile;
        config.cwd = options.cwd || config.cwd;
        const pkgInfo = utils.getPkgInfo(config.cwd);
        config.framework = options.framework || exports.defaultConfig.framework;
        config.watchDirs = getDefaultWatchDirs(config);
        // read from package.json
        if (pkgInfo.egg) {
            mergeConfig(config, pkgInfo.egg.tsHelper);
        }
        // read from local file
        mergeConfig(config, utils.requireFile(utils.getAbsoluteUrlByCwd(configFile, config.cwd)));
        debug('%o', config);
        // merge local config and options to config
        mergeConfig(config, options);
        debug('%o', options);
        // resolve config.typings to absolute url
        config.typings = utils.getAbsoluteUrlByCwd(config.typings, config.cwd);
        this.config = config;
    }
    generateTs(result, file, startTime) {
        const updateTs = (result, file) => {
            const config = this.config;
            const resultList = Array.isArray(result) ? result : [result];
            for (const item of resultList) {
                // check cache
                if (this.isCached(item.dist, item.content)) {
                    return;
                }
                if (item.content) {
                    // create file
                    const dtsContent = `${config_1.dtsComment}\nimport '${config.framework}';\n${item.content}`;
                    utils.writeFileSync(item.dist, dtsContent);
                    this.emit('update', item.dist, file);
                    this.log(`create ${path_1.default.relative(this.config.cwd, item.dist)} (${Date.now() - startTime}ms)`);
                    this.updateDistFiles(item.dist);
                }
                else {
                    if (!fs_1.default.existsSync(item.dist)) {
                        return;
                    }
                    // remove file
                    fs_1.default.unlinkSync(item.dist);
                    delete this.cacheDist[item.dist];
                    this.emit('remove', item.dist, file);
                    this.log(`delete ${path_1.default.relative(this.config.cwd, item.dist)} (${Date.now() - startTime}ms)`);
                    this.updateDistFiles(item.dist, true);
                }
            }
        };
        if (typeof result.then === 'function') {
            return result
                .then(r => updateTs(r, file))
                .catch(e => { this.log(e.message); });
        }
        else {
            updateTs(result, file);
        }
    }
    updateDistFiles(fileUrl, isRemove) {
        const index = this.dtsFileList.indexOf(fileUrl);
        if (index >= 0) {
            if (isRemove) {
                this.dtsFileList.splice(index, 1);
            }
        }
        else {
            this.dtsFileList.push(fileUrl);
        }
    }
    isCached(fileUrl, content) {
        const cacheItem = this.cacheDist[fileUrl];
        if (content && cacheItem === content) {
            // no need to create file content is not changed.
            return true;
        }
        this.cacheDist[fileUrl] = content;
        return false;
    }
}
exports.default = TsHelper;
function createTsHelperInstance(options) {
    return new TsHelper(options);
}
exports.createTsHelperInstance = createTsHelperInstance;
// merge ts helper options
function mergeConfig(base, ...args) {
    args.forEach(opt => {
        if (!opt) {
            return;
        }
        Object.keys(opt).forEach(key => {
            if (key !== 'watchDirs') {
                base[key] = opt[key] === undefined ? base[key] : opt[key];
                return;
            }
            const watchDirs = opt.watchDirs || {};
            Object.keys(watchDirs).forEach(k => {
                const item = watchDirs[k];
                if (typeof item === 'boolean') {
                    if (base.watchDirs[k]) {
                        base.watchDirs[k].enabled = item;
                    }
                }
                else if (item) {
                    // check private generator
                    assert_1.default(!watcher_1.default.isPrivateGenerator(item.generator), `${item.generator} is a private generator, can not configure in config file`);
                    // compatible for deprecated field
                    if (item.path) {
                        item.directory = item.path;
                    }
                    if (base.watchDirs[k]) {
                        Object.assign(base.watchDirs[k], item);
                    }
                    else {
                        base.watchDirs[k] = item;
                    }
                }
            });
        });
    });
}
//# sourceMappingURL=index.js.map